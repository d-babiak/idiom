<div id="left-container">
  <div style="text-align:center; padding-right: 65px; padding-bottom: 20px;">
    <h4>Problems</h4>
  </div>
</div>

<div id="center-container">
  <div id="infovis" style='width: 700px; height: 700px; margin: 0 auto;'>
  </div>
</div>

<div id="right-container">
  <div id="inner-details">
  </div>
</div>

<div id="log">
</div>


<div id='node-modal' class='modal fade'tab-index='-1'>
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">
          <span>&times;</span>
          <span class="sr-only">Close</span></button>
        <h4 class="modal-title" id="myModalLabel">Node info</h4>
      </div>
      <div class="modal-body">
        <a href='#' id='problem-link' class='close' data-dismiss='modal'>
          This will be replaced.
        </a>
      </div>
    </div>
  </div>
</div>

<script>

  $(function(){
    var labelType, useGradients, nativeTextSupport, animate;

    (function() {
      var ua = navigator.userAgent,
          iStuff = ua.match(/iPhone/i) || ua.match(/iPad/i),
          typeOfCanvas = typeof HTMLCanvasElement,
          nativeCanvasSupport = (typeOfCanvas == 'object' || typeOfCanvas == 'function'),
          textSupport = nativeCanvasSupport
            && (typeof document.createElement('canvas').getContext('2d').fillText == 'function');
      //I'm setting this based on the fact that ExCanvas provides text support for IE
      //and that as of today iPhone/iPad current text support is lame
      labelType = (!nativeCanvasSupport || (textSupport && !iStuff))? 'Native' : 'HTML';
      nativeTextSupport = labelType == 'Native';
      useGradients = nativeCanvasSupport;
      animate = !(iStuff || !nativeCanvasSupport);
    })();

    var Log = {
      elem: false,
      write: function(text){
        if (!this.elem)
          this.elem = document.getElementById('log');
        this.elem.innerHTML = text;
        this.elem.style.left = (500 - this.elem.offsetWidth / 2) + 'px';
      }
    };


    function init(){
        //init data
        var json = App.Tree(App.problems.map(function(obj) {
            return obj.attributes;
          })
        );
        //end
        var infovis = document.getElementById('infovis');
        var w = infovis.offsetWidth - 50, h = infovis.offsetHeight - 50;

        //init Hypertree
        var ht = window.ht = new $jit.Hypertree({
          //id of the visualization container
          injectInto: 'infovis',
          //canvas width and height
          width: w,
          height: h,
          //Change node and edge styles such as
          //color, width and dimensions.
          Node: {
              overridable: true,
              dim: 9,
              color: "#f00"
          },
          Edge: {
              lineWidth: 2,
              dim: 2,
              color: "#088"
          },
          Events: {
              enable: true,
              type: 'Native',
              onMouseEnter: function(node, eventInfo, e){
              },
              onMouseLeave: function(node, eventInfo, e){
                ht.canvas.getElement().style.cursor = '';
              }
          },

          onBeforeCompute: function(node){
              Log.write("centering");
          },
          //Attach event handlers and add text to the
          //labels. This method is only triggered on label
          //creation
          onCreateLabel: function(domElement, node){
              domElement.innerHTML = node.name;
              $jit.util.addEvent(domElement, 'click', function () {
                  ht.onClick(node.id, {
                      onComplete: function() {
                          ht.controller.onComplete();
                      }
                  });
              });
          },
          //Change node styles when labels are placed
          //or moved.
          onPlaceLabel: function(domElement, node){
            // if (node.data.special) debugger;
            var title = (node._depth > 0) ? 'some title here' : '';
            domElement.setAttribute('data-toggle', 'tooltip');
            domElement.setAttribute('data-placement', 'top');
            domElement.setAttribute('data-original-title', title);
            $(domElement).tooltip();

            if (node._depth === 0) {
              domElement.setAttribute('data-toggle', "modal");
              domElement.setAttribute('data-target', "#node-modal");
              debugger;
              $('#problem-link').attr('href', '#/problems/' + node.id)
            }

              var style = domElement.style;
              style.display = '';
              style.cursor = 'pointer';
              if (node._depth <= 1) {
                  style.fontSize = "0.8em";
                  style.color = "#ddd";

              } else if(node._depth == 2){
                  style.fontSize = "0.7em";
                  style.color = "#555";

              } else {
                  style.display = 'none';
              }

              var left = parseInt(style.left);
              var w = domElement.offsetWidth;
              style.left = (left - w / 2) + 'px';
          },

          onComplete: function(){
              Log.write("done");

              //Build the right column relations list.
              //This is done by collecting the information (stored in the data property)
              //for all the nodes adjacent to the centered node.
              var node = ht.graph.getClosestNodeToOrigin("current");
              var html = "<h4>" + node.name + "</h4><b>Connections:</b>";
              html += "<ul>";
              node.eachAdjacency(function(adj){
                  var child = adj.nodeTo;
                  if (child.data) {
                      var rel = (child.data.band == node.name) ? child.data.relation : node.data.relation;
                      html += "<li>" + child.name + " " + "<div class=\"relation\">(relation: " + rel + ")</div></li>";
                  }
              });
              html += "</ul>";
              $jit.id('inner-details').innerHTML = html;
          }
        });
        //load JSON data.
        ht.loadJSON(json);
        //compute positions and plot.
        ht.refresh();
        //end
        ht.controller.onComplete();
    }
    init();
  });
</script>
